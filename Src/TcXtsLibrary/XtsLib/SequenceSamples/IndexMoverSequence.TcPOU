<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="IndexMoverSequence" Id="{4ed28eae-b2a7-40a7-8856-6ea87acd0ba0}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK IndexMoverSequence
VAR_INPUT
	ThisMover : IMover;
	XtsTrack : IXtsTrack;
	StateMachine : IPmlStateMachine;
END_VAR
VAR_OUTPUT
END_VAR
VAR
	State : IndexSequenceState;  
	CurrentStation : INT;
	TargetStationPosition : MC_LREAL;
	MoverVelocity : MC_LREAL := 1000.0;
	stSequenceInfo : MoverSequenceInfo;
END_VAR
VAR_IN_OUT
	StationArray : ARRAY[*] OF IProcess;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[CASE State OF
	IndexSequenceState.Init:
		IF ThisMover.isDetected() THEN
			State := IndexSequenceState.Available;
		END_IF
		
	IndexSequenceState.Available:
		IF StateMachine.GetCurrentState() = E_PMLState.ePMLState_Starting THEN
			State := IndexSequenceState.MovingToStart;
		END_IF
		IF StateMachine.GetCurrentState() = E_PMLState.ePMLState_Aborting THEN
			State := IndexSequenceState.Aborting;
		END_IF
		
	IndexSequenceState.MovingToStart:
		IF ThisMover.isAtPosition(position := XtsTrack.HomePosition) THEN
			State := IndexSequenceState.AtStart;
		END_IF
		IF StateMachine.GetCurrentState() = E_PMLState.ePMLState_Aborting THEN
			State := IndexSequenceState.Aborting;
		END_IF
			
	IndexSequenceState.AtStart:
		IF StationArray[LOWER_BOUND(StationArray,1)].IsReady() THEN
			State := IndexSequenceState.GetNextMove;
		END_IF
		IF StateMachine.GetCurrentState() = E_PMLState.ePMLState_Aborting THEN
			State := IndexSequenceState.Aborting;
		END_IF
		
	IndexSequenceState.MovingToStation:
		IF ThisMover.isStationary() THEN 
			IF ThisMover.isAtPosition(TargetStationPosition) THEN
				IF StationArray[CurrentStation].IsProcess THEN
					State := IndexSequenceState.AtProcess;
				ELSE
					State := IndexSequenceState.AtStation;
				END_IF
				StationArray[CurrentStation].HasMover(ThisMover);
			ELSE
				State := IndexSequenceState.QueuedAtStation;
			END_IF
		END_IF
		IF StateMachine.GetCurrentState() = E_PMLState.ePMLState_Aborting THEN
			State := IndexSequenceState.Aborting;
		END_IF
		
	IndexSequenceState.QueuedAtStation:
		IF NOT ThisMover.isStationary() THEN
				State := IndexSequenceState.MovingToStation;
		END_IF
		IF StateMachine.GetCurrentState() = E_PMLState.ePMLState_Aborting THEN
			State := IndexSequenceState.Aborting;
		END_IF

	IndexSequenceState.AtStation:
		IF StationArray[CurrentStation].isComplete() THEN
			State := IndexSequenceState.GetNextMove;
		END_IF
		IF StateMachine.GetCurrentState() = E_PMLState.ePMLState_Aborting THEN
			State := IndexSequenceState.Aborting;
		END_IF

	IndexSequenceState.AtProcess:
		ThisMover.MoveTo(Position := StationArray[CurrentStation].EndPosition,
								Velocity := StationArray[CurrentStation].ProcessVelocity,
								BackwardMove := FALSE);
		State := IndexSequenceState.InProcess;
		IF StateMachine.GetCurrentState() = E_PMLState.ePMLState_Aborting THEN
			State := IndexSequenceState.Aborting;
		END_IF
								
	IndexSequenceState.InProcess:
		IF ThisMover.isStationary() THEN 
			IF ThisMover.isAtPosition(StationArray[CurrentStation].EndPosition) THEN
				State := IndexSequenceState.GetNextMove;
			END_IF
		END_IF
		IF StateMachine.GetCurrentState() = E_PMLState.ePMLState_Aborting THEN
			State := IndexSequenceState.Aborting;
		END_IF
	
	IndexSequenceState.GetNextMove:
		IF CurrentStation = UPPER_BOUND(StationArray,1) THEN
			IF ThisMover.MoveTo(Position := XtsTrack.HomePosition,
							Velocity := MoverVelocity,
							BackwardMove := FALSE) THEN
				State := IndexSequenceState.MovingToStart;
				StationArray[CurrentStation].MoverAway();
				CurrentStation := 0; 
			END_IF
		ELSE
			State := IndexSequenceState.GoToNextStation;
		END_IF
		IF StateMachine.GetCurrentState() = E_PMLState.ePMLState_Aborting THEN
			State := IndexSequenceState.Aborting;
		END_IF
		
	IndexSequenceState.GoToNextStation:
		IF StationArray[CurrentStation + 1].IsProcess THEN
			TargetStationPosition := StationArray[CurrentStation + 1].StartPosition;
		ELSE
			TargetStationPosition := StationArray[CurrentStation + 1].Position;
		END_IF
		IF 	ThisMover.MoveTo(Position := TargetStationPosition,
							Velocity := MoverVelocity,
							BackwardMove := FALSE) THEN
			IF CurrentStation <> 0 THEN
				StationArray[CurrentStation].MoverAway();	
			END_IF		
			CurrentStation := CurrentStation + 1;
			State := IndexSequenceState.MovingToStation;
		END_IF				
		IF StateMachine.GetCurrentState() = E_PMLState.ePMLState_Aborting THEN
			State := IndexSequenceState.Aborting;
		END_IF
		
	IndexSequenceState.Aborting:
		IF StateMachine.GetCurrentState() = E_PMLState.ePMLState_Aborted THEN
			State := IndexSequenceState.Available;
			CurrentStation := 0;
			TargetStationPosition := 0.0;
		END_IF
END_CASE

//Cyclic update info data
stSequenceInfo.CurrentStation := CurrentStation;
stSequenceInfo.MoverId := ThisMover.AxisRef.NcToPlc.AxisId;
stSequenceInfo.State := State;
stSequenceInfo.Velocity := MoverVelocity;]]></ST>
    </Implementation>
    <LineIds Name="IndexMoverSequence">
      <LineId Id="810" Count="9" />
      <LineId Id="968" Count="1" />
      <LineId Id="967" Count="0" />
      <LineId Id="820" Count="4" />
      <LineId Id="965" Count="1" />
      <LineId Id="964" Count="0" />
      <LineId Id="825" Count="4" />
      <LineId Id="962" Count="1" />
      <LineId Id="961" Count="0" />
      <LineId Id="830" Count="83" />
      <LineId Id="970" Count="1" />
      <LineId Id="915" Count="0" />
      <LineId Id="960" Count="0" />
      <LineId Id="916" Count="5" />
      <LineId Id="39" Count="0" />
      <LineId Id="1002" Count="0" />
      <LineId Id="1001" Count="0" />
      <LineId Id="1003" Count="3" />
    </LineIds>
  </POU>
</TcPlcObject>